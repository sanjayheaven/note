# 数据库

## ACID

事务是指对系统进行的一组操作，为了保证系统的完整性，事务需要具有 ACID 特性

### 原子性（Atomic）

一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。实现事务的原子性，要支持回滚操作，在某个操作失败后，回滚到事务执行之前的状态。  
回滚实际上是一个比较高层抽象的概念，大多数 DB 在实现事务时，是在事务操作的数据快照上进行的（比如，MVCC），并不修改实际的数据，如果有错并不会提交，所以很自然的支持回滚。  
而在其他支持简单事务的系统中，不会在快照上更新，而直接操作实际数据。可以先预演一边所有要执行的操作，如果失败则这些操作不会被执行，通过这种方式很简单的实现了原子性。

### 一致性（Consistency）

**最为基础，重要**

一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度。  
事务可以不同程度的一致性：

- 强一致性  
  读操作可以立即读到提交的更新操作。
- 弱一致性  
  提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。
- 最终一致性  
  是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。
- 单调一致性  
  如果一个进程已经读到一个值，那么后续不会读到更早的值。
- 会话一致性  
  保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。

### 隔离性（Isolation）

并发事务之间互相影响的程度，比如一个事务会不会读取到另一个未提交的事务修改的数据。  
在事务并发操作时，可能出现的问题有：

- 脏读  
  事务 A 修改了一个数据，但未提交，事务 B 读到了事务 A 未提交的更新结果，如果事务 A 提交失败，事务 B 读到的就是脏数据。
- 不可重复读（针对数据项）
  在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务 B 在事务 A 提交前读到的结果，和提交后读到的结果可能不同。不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。另一种方法是通过 MVCC 可以在无锁的情况下，避免不可重复读。
- 幻读（针对数据集合）  
  在同一个事务中，同一个查询多次返回的结果不一致。事务 A 新增了一条记录，事务 B 在事务 A 提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读

事务的隔离级别从低到高有：

- Read Uncommitted  
  最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。
- Read Committed  
  只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。
- Repeated Read  
  在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。
- Serialization  
   事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。

通常，在工程实践中，为了性能的考虑会对隔离性进行折中。

### 持久性（Durability）

事务提交后，对系统的影响是永久的。


## 命令学习记录
- db.runCommand({getLastError:1}) 9.9.4节  
- find $all命令 数组交错匹配 find("fruit.2") 用index指定下标
- 游标是个好东西 
- $snapshot 快照 返回不变的集合
- createIndex
- explain分析命令 是个好东西


## 瞬间完成
mongodb （插入、删除、更新）瞬间完成，客户端不用等待，就得到结果。  
**问题：数据库可能未执行成功**   
- 索引相同，但是插入不报错  
在一般的系统要求不高，比如日志记录系统，监控分析系统。
在数据强一致性要求很高的系统，比如下单系统，支付系统 必须考虑到！！

## 索引 去看看数据库 树的结构
- createIndex创建索引。
- 索引不要太多。多的话，查快，改慢
> 有个索引{a:1,b:1,c:1...z:1} 实际上是 {a:1,b:1,c:1} 使用{b：1,c:1,a:1}不会被优化
这和数据库组织文档形式有关。索引也分先后顺序   

**举个例子，用户名和日期创建索引**
比如一天每个用户都是来个几万条信息，那如何获取最新的信息？

**为排序做索引**


**思考问题**
- 会做什么样的查询，其中哪些键需要索引
- 每个键的索引方向如何去抉择
- 如何应对扩展，有没有中不同的键的排列可以使常用的数据更多保留在内存中
